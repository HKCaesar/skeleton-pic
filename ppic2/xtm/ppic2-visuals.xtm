(sys:load "libs/external/glfw3.xtm")

(bind-val width i32 800)
(bind-val height i32 600)

(bind-val window GLFWwindow*
  (glfw_init_and_create_interaction_window width height))

(sys:load "libs/external/nanovg.xtm")

(bind-val vg NVGcontext* (nvg_create_context))
(bind-val pixel_ratio float (glfw_get_pixel_ratio window))

(sys:load "libs/external/gl/gl-objects.xtm")
(sys:load "libs/external/datavis.xtm")

(call-as-xtlang
 (nvgCreateFont vg "default" "/Library/Fonts/Arial.ttf")
 (nvgFontFace vg "default")
 (nvgFontSize vg 30.))

;; OpenGL setup

;; (call-as-xtlang
;;  (glEnable GL_BLEND)
;;  (glBlendFunc GL_SRC_ALPHA GL_ONE))

;;;;;;;;;;;;
;; fields ;;
;;;;;;;;;;;;

;; this data should have interleaved the `bases' of the field arrows
;; (i.e. the grid) in 2D with the ndim (i.e. 3D) field components

(bind-val field_arrows float*)

(bind-func ppic2_visuals_field_init
  (lambda ()
    (let ((field_arrows_:float* (halloc (* 4 nx ny)))
          (idx 0))
      (set! field_arrows field_arrows_)
      ;; set base verts (i.e. every second vec2) to regular grid
      (doloop (i nx)
        (doloop (j ny)
          (set! idx (* (+ (* i nx) j) 4))
          (pset! field_arrows
                 idx
                 (/ (convert i float) (convert nx float)))
          (pset! field_arrows
                 (+ idx 1)
                 (/ (convert j float) (convert ny float)))))
      void)))

(ppic2_visuals_field_init)

(bind-func ppic2_visuals_copy_field_data
  (lambda (field:float* scale_factor:float)
    (let ((field_arrows_idx 0)
          (field_idx 0)
          (max_length 0.))
      ;; (doloop (k (* nxe ny))
      ;;   (set! field_idx (* k ndim))
      ;;   (if (> (pref field field_idx) max_length)
      ;;       (set! max_length
      ;;             (pref field field_idx)))
      ;;   (if (> (pref field (+ field_idx 1)) max_length)
      ;;       (set! max_length
      ;;             (pref field (+ field_idx 1)))))
      ;; (if (> max_length 0.25)
      ;;     (set! scale_factor (* 0.25 (/ 1.0 max_length))))
      (doloop (i nx)
        (doloop (j ny)
          (set! field_arrows_idx (* (+ (* i nx) j) 4))
          (set! field_idx (+ (* i nxe) j 1))
          (pset! field_arrows ;; x component
                 (+ field_arrows_idx 2)
                 (+ (pref field_arrows field_arrows_idx)
                    (* scale_factor (pref field field_idx))))
          (pset! field_arrows ;; x component
                 (+ field_arrows_idx 3)
                 (+ (pref field_arrows (+ field_arrows_idx 1))
                    (* scale_factor (pref field (+ field_idx 1))))))))))

;; not sure why fxyze tends to get massive (junk) numbers in it, but
;; this hack cleans them out.
(bind-func ppic2_visuals_reset_arrows_buffer
  (lambda ()
    (let ((idx 0))
      (doloop (i nx)
        (doloop (j ny)
          (set! idx (* (+ (* i ny) j) 4))
          ;; (println "idx:" idx)
          (if (> (fabs (pref field_arrows (+ 2 idx))) 1.0)
              (pset! field_arrows
                     (+ 2 idx)
                     (pref field_arrows (+ 0 idx))))
          (if (> (fabs (pref field_arrows (+ 3 idx))) 1.0)
              (pset! field_arrows
                     (+ 3 idx)
                     (pref field_arrows (+ 1 idx)))))))))

(bind-func ppic2_visuals_field_draw
  (let ((bounds (Rect 0. 0. (convert width) (convert height))))
    (lambda ()
      (ppic2_visuals_copy_field_data fxye .1)
      (dv_draw_line_segments vg bounds field_arrows 1000)
      void)))

;; magnitude spectrum

(dv_draw_bars.gain 100.)

(bind-func ppic2_qt_spectrum_draw
  (let ((nbins (* nye kxp))
        (spec:float* (zalloc nbins))
        (bounds:Rect* (Rect (* (convert width) .5)
                            (* (convert height) .5)
                            (* (convert width) .5)
                            (* (convert height) .5))))
    (lambda ()
      (doloop (i nbins)
        (pset! spec i (* .3 (sqrt (+ (* (tref (pref-ptr qt i) 0)
                                        (tref (pref-ptr qt i) 0))
                                     (* (tref (pref-ptr qt i) 1)
                                        (tref (pref-ptr qt i) 1)))))))
      (dv_draw_bars vg bounds spec (convert nbins)))))

(bind-func ppic2_qe_spectrum_draw
  (let ((nbins (/ (* nxe (pref nypmx_ptr 0)) 2))
        (spec:float* (zalloc nbins))
        (bounds:Rect* (Rect (* (convert width) .5)
                            (* (convert height) .5)
                            (* (convert width) .5)
                            (* (convert height) .5))))
    (lambda ()
      (doloop (i nbins)
        (pset! spec i (* .3 (sqrt (+ (* (tref (pref-ptr (cast qe Complexf*) i) 0)
                                        (tref (pref-ptr (cast qe Complexf*) i) 0))
                                     (* (tref (pref-ptr (cast qe Complexf*) i) 1)
                                        (tref (pref-ptr (cast qe Complexf*) i) 1)))))))
      (dv_draw_bars vg bounds spec (convert nbins)))))

;;;;;;;;;;;;;;;
;; particles ;;
;;;;;;;;;;;;;;;

(bind-func dv_draw_scatter_points_fixed_size
  "draw 2D points for a scatterplot - particle aware!

@param vg - nanovg context pointer
@param bounds - bounding rect in which to draw the points
@param points - pointer to point data (packed) e.g. x1,y1,x2,y2,...
@param npoints - number of points
@param size - point size"
  (let ((stroke_width 2.:f)
        (padding 20.)
        (colour (NVGcolor 1. 1. 1. .2)))
    (lambda (vg bounds:Rect* points:float* npoints:i64 size:float)
      (if (< npoints 1)
          (begin (println "npoints must be at least 1 for scatter_points") -1)
          (let ((x (+ (tref bounds 0) padding))
                (y (+ (tref bounds 1) padding))
                (w (- (tref bounds 2) (* 2. padding)))
                (h (- (tref bounds 3) (* 2. padding)))
                (i 0))
            ;; (nvgFillWidth vg stroke_width)
            (_nvgFillColor vg colour)
            ;; add circles to path
            (dotimes (i npoints)
              (nvgBeginPath vg)
              (nvgCircle vg
                         (+ x (* w (/ (pref points (* i (convert idimp i64))) (convert nx))))
                         (+ y (* h (- 1. (/ (pref points (+ (* i (convert idimp i64)) 1)) (convert (pref nyp_ptr 0))))))
                         size)
              (nvgFill vg))
            0)))))

(bind-func ppic2_visuals_particles_draw
  (let ((bounds (Rect 0. 0. (* .5 (convert width)) (convert height))))
    (lambda ()
      (dv_draw_scatter_points_fixed_size vg bounds part (convert (pref npp_ptr 0)) 5.)
      void)))

;;;;;;;;;;;;;;;;;;;;
;; charge density ;;
;;;;;;;;;;;;;;;;;;;;

(bind-func ppic2_visuals_charge_density_draw
  (let ((padding 20.)
        (bounds (Rect 0. 0. (* .5 (convert width)) (convert height)))
        (tile_fill (NVGcolor .6 1. .1 .35))
        (gain 2000.))
    (lambda ()
      (let ((x (+ (tref bounds 0) padding))
            (y (+ (tref bounds 1) padding))
            (w (- (tref bounds 2) (* 2. padding)))
            (h (- (tref bounds 3) (* 2. padding)))
            (i 0))
        ;; add circles to path
        (doloop (col nx)
          (doloop (row ny)
            (tset! tile_fill 3 (* gain (pref qe (+ (* col nxe) row))))
            (_nvgFillColor vg tile_fill)
            (nvgBeginPath vg)
            (nvgCircle vg
                       (+ x (* w (/ (convert row float) (convert nx float))))
                       (+ y (* h (- 1. (/ (convert col float) (convert ny float)))))
                       (* gain 10. (pref qe (+ (* col nxe) row))))
            (nvgFill vg)))
        void))))

;; (/ (convert width float) (convert nx float))
;; (/ (convert height float) (convert ny float))

;; histograms (currently taken from math.xtm, but with some modifications)

(bind-type HistBin <float,float>
  "a histogram bin: <lower,count>")

(bind-func HistBin_print
  "specialised print function for HistBin*"
  (lambda (histbin:HistBin*)
    (if (null? histbin)
        (printf "<HistBin 0x0>")
        (printf "<HistBin %p minval=%f count=%f>"
                histbin
                (convert (tref histbin 0) double)
                (convert (tref histbin 1) double)))
    void))

(bind-poly print HistBin_print)

(bind-func HistBin_toString
  "specialised toString function for HistBin*"
  (lambda (histbin:HistBin*)
    (let ((str:i8* (salloc 256)))
      (if (null? histbin)
          (sprintf str "<HistBin 0x0>")
          
          (sprintf str
                   "<HistBin %p minval=%f count=%f>"
                   histbin
                   (convert (tref histbin 0) double)
                   (convert (tref histbin 1) double)))
      (Str str))))

(bind-poly toString HistBin_toString)

;; this version takes extra arguments to do with the stride required
;; for the part data buffer

(bind-func histogram_float_full
  (lambda (hist:HistBin* buf:float* buflen lower upper nbins amp dc)
    (let ((current_bin:HistBin* null)
          (range (- upper lower))
          (i 0))
      (if (not (> range 0.))
          (begin
            (println "Error in histogram: range (- upper lower) must be greater than 0.0")
            null)
          (begin
            ;; setup the bins
            (doloop (i nbins)
              (tset! (pref-ptr hist i)
                     0
                     (+ lower (* (convert i) (/ range (convert nbins)))))
              (tset! (pref-ptr hist i) 1 0.))
            (doloop (i buflen)
              (set! current_bin
                    ;; use "mod nbins" to make sure it always goes
                    ;; into a valid slot in memory
                    (pref-ptr hist (% (convert (* (convert nbins float) (/ (- (pref buf (+ (* i amp) dc)) lower) range)) i64) nbins)))
              (tset! current_bin 1 (+ (tref current_bin 1) 1.0)))
            hist)))))

(bind-func histogram_float_range
  "like the full version, but use the min and max values in the buffer as upper and lower"
  (lambda (hist:HistBin* buf:float* buflen nbins amp dc)
    (let ((lower 0.0)
          (upper 0.0))
      ;; find max/min values
      (doloop (i buflen)
        (if (< (pref buf i) lower)
            (set! lower (pref buf i)))
        (if (> (pref buf i) upper)
            (set! upper (pref buf i))))
      (histogram_float_full hist buf buflen lower upper nbins amp dc))))

(bind-poly histogram histogram_float_full)
(bind-poly histogram histogram_float_range)

;; now for the actual histogram visuals

(bind-val vhist_nbins i64 100)
(bind-val vhist_data HistBin*)

(bind-func ppic2_visuals_vhist_init
  (lambda ()
    (let ((hb:HistBin* (halloc (* vhist_nbins 3))))
      (set! vhist_data hb))))

(ppic2_visuals_vhist_init)

(bind-func ppic2_visuals_vhist_draw
  (let ((bounds (Rect (* (convert width) .5) 0.
                      (* (convert width) .5) (* (convert height) .5)))
        (xcolor (NVGcolor 1. 0. 0. 1.))
        (xrect (Rect (tref bounds 0) (tref bounds 1)
                     (/ (tref bounds 2) 2.) (tref bounds 3)))
        (ycolor (NVGcolor 0. 1. 0. 1.))
        (yrect (Rect (+ (tref bounds 0) (/ (tref bounds 2) 2.)) (tref bounds 1)
                     (/ (tref bounds 2) 2.) (tref bounds 3)))
        (histrange 5.)
        (histscale .001)
        (font_size 30.))
    (lambda ()
      ;; x histogram
      (histogram vhist_data part (convert (pref npp_ptr 0)) (* -1. histrange) histrange vhist_nbins 4 2)
      ;; y histogram
      (histogram (pref-ptr vhist_data vhist_nbins) part (convert (pref npp_ptr 0)) (* -1. histrange) histrange vhist_nbins 4 3)
      ;; apply some scaling
      (doloop (i (* 3 vhist_nbins))
        (tset! (pref-ptr vhist_data i) 0 (+ .5 (/ (tref (pref-ptr vhist_data i) 0) (* 2. histrange))))
        (tset! (pref-ptr vhist_data i) 1 (* (tref (pref-ptr vhist_data i) 1) histscale)))
      ;; nvg labels
      (nvgFontSize vg font_size)
      ;; vx histogram
      (dv_draw_title vg xrect "vx")
      (dv_draw_axes_2D vg xrect)
      (dv_draw_line.stroke_width (convert (+ (* (cos (* .01 (convert ntime))) 2.) 3.) float))
      (dv_draw_line vg xrect (cast vhist_data float*) vhist_nbins)
      ;; ;; vy histogram
      (dv_draw_title vg yrect "vy")
      (dv_draw_axes_2D vg yrect)
      (dv_draw_line vg yrect (cast (pref-ptr vhist_data vhist_nbins) float*) vhist_nbins)
      void)))

;; (bind-func external_field
;;   (lambda ()
;;     (doloop (i (convert np i64))
;;       (if (and (< (pref part (+ (* i (convert idimp i64)) 1)) (+ (convert nyh) 2.))
;;                (> (pref part (+ (* i (convert idimp i64)) 1)) (- (convert nyh) 2.))
;;                (< (random) .1))
;;           (pset! part (+ (* i (convert idimp i64)) 3) (* -1. (pref part (+ (* i (convert idimp i64)) 3))))))))

;; load indicators

(bind-dylib libc
  (cond ((string=? (sys:platform) "OSX") "libc.dylib")
        ((string=? (sys:platform) "Linux") "libc.so")
        ((string=? (sys:platform) "Windows") "libc.dll")))

(bind-lib libc getloadavg [i32,double*,i32]*)

(bind-func print_loadavg
  (lambda ()
    (let ((load:double* (salloc 3)))
      (if (<> (getloadavg load 3) -1)
          (begin
            (println "load average")
            (println " 1 min:"(pref load 0))
            (println " 5 min:"(pref load 1))
            (println "15 min:"(pref load 2))
            (println))))))

;; draw all the things

(bind-func ppic2_visuals
  (lambda ()
    ;; nanovg
    (nvg_clear)
    (nvgBeginFrame vg width height pixel_ratio)
    (nvgResetTransform vg)
    (ppic2_visuals_charge_density_draw)
    ;; (ppic2_visuals_particles_draw)
    (ppic2_qt_spectrum_draw)
    ;; (ppic2_visuals_field_draw)
    (ppic2_visuals_vhist_draw)
    (nvgEndFrame vg)
    ;; poll events, swap buffers
    (glfwPollEvents)
    (glfwSwapBuffers window)))

;; start it running
;; (ppic2_visuals_loop (now) (/ 1. 30.))
